# The Juice DApp — Audit Notes

## testcode.html
- **Lines 1768-1807 – Missing join deadline guard in `doCreate` preview/UX:** UI never surfaces creator-side join deadline enforcement beyond range clamping; contract may still accept short/expired durations. Add an explicit check that `joinDeadline` is at least current block time plus the chosen minutes and display a warning if creation is attempted near expiry to avoid "missing revert data" when contract rejects stale timestamps. Example: verify `jm*60 > 60` buffer or query chain time before submit.
- **Lines 1822-1844 – `doJoin` omits join deadline and stake validation:** The join flow only checks `state===0`; it never checks `block.timestamp < joinDeadline` or that `b[2]` (stake) matches `msg.value` in the current network currency. Add a `now <= b[4]` guard and ensure `stakeWei > 0`, otherwise the contract can revert with no context and users could front‑run fee/stake mismatches.
- **Lines 1822-1844 – No self-join or duplicate join prevention:** UI does not block the creator from calling `joinChallenge` or an already-joined opponent from re-joining, relying solely on contract revert. Compare caller to `b[0]`/`b[1]` and surface a UI error first to avoid revert-without-data confusion.
- **Lines 1852-1892 – `doVote` allows voting in any state:** There is no guard that the challenge has two participants (`b[1]!=0`) and is in the voting window/state (e.g., `state===1` or `now<=resolveDeadline`). Submitting while open/expired will revert. Add checks before calling `submitOutcomeVote`.
- **Lines 1852-1892 – Role inversion risk without explicit mapping:** The front-end infers `creatorWon` from the caller address. If addresses are checksummed differently or empty, an unrecognized caller falls into the "opponent" path and may flip the vote, leading to inconsistent UI vs contract revert. Validate caller matches creator/opponent and reject otherwise.
- **Lines 1895-1934 – Refund gating ignores the no-vote timeout case:** UI only permits refunds when no opponent joined past `joinDeadline` or when votes mismatch after `resolveDeadline`. If neither party votes, the UI blocks refund even though the contract may allow timeout refunds, forcing users to craft manual transactions. Add a `state===1 && now>resolveDeadline && !votesSet` branch.
- **Lines 1895-1934 – Potential silent failure on timestamp precision:** Front-end uses `Date.now()/1000` without chain time buffer; minor clock skew can cause premature rejections or contract reverts for borderline deadlines. Use `provider.getBlock('latest')` timestamp to align with chain time.
- **Lines 1938-1972 – Payout assumes consensus only:** UI demands both votes match before calling `resolveChallenge`, but if the contract allows single-signer resolution after `resolveDeadline` or uses different rules, the UI will block valid payouts, leaving funds stuck. Align the UI checks with on-chain logic or expose a "force resolve" path after deadline.
- **Lines 1200-1325 & 1337-1344 – Network toggle does not reset signer/provider:** Switching between mainnet/testnet merely flips labels and calls `ensureBase` on the injected wallet. Existing `provider`/`signer` instances remain bound to the previous chain, leading to transactions sent to the wrong contract and revert data loss. Recreate `provider`/`signer` after a network toggle or force a reconnect.
- **Lines 1680-1752 – WalletConnect lifecycle gaps:** After a WalletConnect disconnect, `wcProvider` is nulled but `provider`/`signer` may still reference the dead session; subsequent calls throw `missing revert data` style errors. Listen for `session_delete`/`disconnect` events and clear signer state, prompting a reconnect.
- **Lines 1496-1550 – Fee display hardcoded to 2.5% (`FEE_BPS=250`):** UI never reads the fee from the contract. If the contract fee changes, users pay a different amount than shown. Fetch fee from on-chain storage or surface a warning if the fetched fee differs from `FEE_BPS` before calling `openChallenge`.
- **Lines 1760-1765 & 1830-1834 – `requireBetId`/lookups lack bounds/format checks:** Bet IDs are blindly converted to `BigInt` and passed to the contract; extremely large values or leading zeros could revert or reference empty slots. Enforce a reasonable max (e.g., `nextChallengeId-1`) and strip leading zeros to reduce revert-without-data cases.
- **Lines 1100-1190 – Clipboard & fetch promises unhandled:** `navigator.clipboard.writeText` and `fetch` are used without `.catch`, so browsers that deny permission leave the UI silently stale. Add `.catch` handlers to show the error modal for usability.
- **Lines 900-1050 – USD preview uses stale `ETH_USD` when API fails:** On failure, the code keeps the last price but continues to show precise USD values without a stale marker. Display a "stale" badge or stop converting when the price fetch fails to avoid misleading stakes.
- **Lines 1768-1800 – No slippage/fee buffer on `stakeEth` precision:** `stakeEthNum.toFixed(4)` truncates inputs; tiny values may round up/down causing underpayment vs contract expectations. Parse using full precision and rely on `parseEther` instead of rounding to 4 decimals.
- **Lines 1250-1290 – Network indicator may show "connected" on wrong chain:** `updateWalletNetworkLabel` marks chips as active if chainId matches CURRENT_NETWORK, but `CURRENT_NETWORK` is never updated when the wallet switches chains externally. Add a listener to sync `CURRENT_NETWORK` to the wallet’s actual chain to avoid mis-targeted transactions.

## REVIEW.md
- Document is outdated (single bullet) and omits the above findings. Expand it or link to this audit so the issues are not missed during triage.
